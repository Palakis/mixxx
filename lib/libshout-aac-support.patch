diff -Naur libshout-2.3.1/include/shout/shout.h.in libshout-2.3.1-modified/include/shout/shout.h.in
--- libshout-2.3.1/include/shout/shout.h.in	2012-02-01 22:02:18.000000000 +0100
+++ libshout-2.3.1-modified/include/shout/shout.h.in	2017-08-22 21:41:46.486930999 +0200
@@ -42,6 +42,7 @@
 #define SHOUT_FORMAT_OGG	(0)
 #define SHOUT_FORMAT_MP3	(1)
 #define SHOUT_FORMAT_WEBM	(2)
+#define SHOUT_FORMAT_AAC    (3)
 /* backward-compatibility alias */
 #define SHOUT_FORMAT_VORBIS	SHOUT_FORMAT_OGG
 
diff -Naur libshout-2.3.1/src/aac.c libshout-2.3.1-modified/src/aac.c
--- libshout-2.3.1/src/aac.c	1970-01-01 01:00:00.000000000 +0100
+++ libshout-2.3.1-modified/src/aac.c	2017-08-22 21:42:18.346992999 +0200
@@ -0,0 +1,237 @@
+/* -*- c-basic-offset: 8; -*- */
+/* aac.c: libshout AAC format handler
+ *
+ *  Copyright (C) 2010 Aupeo GmbH, Arthur Taylor <arthur@aupeo.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the Free
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * AAC frame handling courtesy Arthur Taylor
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <malloc.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include <shout/shout.h>
+#include "shout_private.h"
+
+#define ADTS_HEADER_SIZE 8 /* Actual ADTS Header size -> 56 bits */
+
+#define min(a,b) (a<b ? a : b)
+
+#undef TRACE
+#ifdef TRACE
+#define trace(x, ...) fprintf(stderr, x, ##__VA_ARGS__)
+#else
+#define trace(x, ...) ;
+#endif
+
+#define DEBUG
+#ifdef DEBUG
+#define debug(x, ...) fprintf(stderr, x, ##__VA_ARGS__)
+#else
+#define debug(x, ...) ;
+#endif
+
+typedef struct {
+    int version;
+    int channels;
+    int sampling_rate;
+    int bitrate;
+    int length;
+    int object_type;
+    int headertype;
+} faadAACInfo;
+
+static int sample_rates[] = {96000,88200,64000,48000,44100,32000,24000,22050,16000,12000,11025,8000};
+
+typedef enum {
+  SEEK,
+  PARSE_HEADER,
+  READ_FRAME
+} ParseState_e;
+
+struct aac_data {
+  faadAACInfo *info;
+  ParseState_e state;
+  unsigned char *buffer;
+  int buffer_position;
+  int buffer_length;
+  int buffer_allocated;
+  int frame_length;
+  int frames_sent;
+  float frames_per_second;
+};
+typedef struct aac_data aac_data_t;
+
+/* -- static prototypes -- */
+static int process_local_buffer(shout_t *self, aac_data_t *data);
+static int send_aac(shout_t *self, const unsigned char *data, size_t len);
+static void close_aac(shout_t *self);
+
+int shout_open_aac(shout_t *self)
+{
+  aac_data_t *aac_data;
+  if (!(aac_data = (aac_data_t *)calloc(1, sizeof(aac_data_t))))
+    return SHOUTERR_MALLOC;
+  self->format_data = aac_data;
+
+  memset(aac_data, 0, sizeof(aac_data));
+
+  aac_data->info = (faadAACInfo *)calloc(1, sizeof(faadAACInfo));
+  aac_data->state = SEEK;
+
+  self->send = send_aac;
+  self->close = close_aac;
+
+  return SHOUTERR_SUCCESS;
+}
+
+static void copy_to_local_buffer(aac_data_t *data, const unsigned char *buf, size_t offset, size_t length) {
+  trace("%s\n", __FUNCTION__);
+  data->buffer = malloc(length);
+  memcpy(data->buffer, buf + offset, length);
+  data->buffer_position = 0;
+  data->buffer_length = length;
+  data->buffer_allocated = length;
+}
+
+static void append_to_local_buffer(aac_data_t *data, const unsigned char *buf, size_t length) {
+  trace("%s\n", __FUNCTION__);
+  if (data->buffer_allocated - data->buffer_length < length) {
+    data->buffer = realloc(data->buffer, data->buffer_length + length);
+    data->buffer_allocated = data->buffer_length + length;
+  }
+  memcpy(data->buffer + data->buffer_length, buf, length);
+  data->buffer_length += length;
+}
+
+static void read_header_data(aac_data_t *data) {
+  trace("%s\n", __FUNCTION__);
+  int version_id = data->buffer[1] & 0x08;
+  data->info->object_type = (data->buffer[2]&0xC0)>>6;
+  int sr_idx = (data->buffer[2]&0x3C)>>2;
+  data->info->channels = ((data->buffer[2]&0x01)<<2)|((data->buffer[3]&0xC0)>>6);
+
+  data->frames_per_second = sample_rates[sr_idx] / 1024.f;
+  trace("Frames per sec: %f\n", data->frames_per_second);
+
+  if (version_id == 0) {
+    data->info->version = 4;
+  } else { /* MPEG-2 */
+    data->info->version = 2;
+  }
+// XXX Bail if frame is too long
+  data->frame_length = ((((unsigned int)data->buffer[3] & 0x3)) << 11)
+                      | (((unsigned int)data->buffer[4]) << 3) | (data->buffer[5] >> 5);
+}
+
+static void shift_data_left(aac_data_t *data, size_t amount) {
+  trace("%s\n", __FUNCTION__);
+  size_t shift = min(amount, data->buffer_length);
+  memmove(data->buffer, data->buffer + shift, data->buffer_length - shift);
+  data->buffer_length -= shift;
+}
+
+static int send_frame(shout_t *self, aac_data_t *data) {
+  trace("%s\n", __FUNCTION__);
+  int ret;
+  if (data->buffer_length < data->frame_length)
+   return SHOUTERR_SUCCESS;
+
+  data->frames_sent++;
+  self->senttime = (int64_t)((double)data->frames_sent * 1000000/(double)data->frames_per_second);
+
+  ret = shout_send_raw(self, data->buffer, data->frame_length);
+  if (ret != data->frame_length)
+    return SHOUTERR_SOCKET;
+
+  shift_data_left(data, data->frame_length);
+  data->state = PARSE_HEADER;
+  return process_local_buffer(self, data);
+}
+
+static int valid_header_bytes(const unsigned char *buf) {
+  return buf[0] == 0xFF && (buf[1] & 0xF6) == 0xF0;
+}
+
+static int process_local_buffer(shout_t *self, aac_data_t *data) {
+  trace("%s\n", __FUNCTION__);
+  if (!data->buffer) {
+    return SHOUTERR_SUCCESS;
+  }
+  switch (data->state) {
+    case PARSE_HEADER:
+      if (data->buffer_length < ADTS_HEADER_SIZE) {
+        return SHOUTERR_SUCCESS;
+      }
+      if (!valid_header_bytes(data->buffer)) {
+        fprintf(stderr, "Invalid header bytes detected. Quittung\n");
+        exit(1);
+      }
+      read_header_data(data);
+      data->state = READ_FRAME;
+      return process_local_buffer(self, data);
+    case READ_FRAME:
+      return send_frame(self, data);
+    case SEEK:
+      fprintf(stderr, "Shouldn't get here\n");
+      exit(1);
+      break;
+  }
+  return SHOUTERR_SUCCESS;
+}
+
+static int send_aac(shout_t* self, const unsigned char* buf, size_t len)
+{
+  aac_data_t *data = (aac_data_t *)self->format_data;
+  int i = 0;
+  switch (data->state) {
+    case SEEK:
+      debug("Looking for frame header\n");
+      while (i<len-2) {
+        if (valid_header_bytes(buf + i)) {
+          debug("Found Frame Header\n");
+          copy_to_local_buffer(data, buf, i, len - i);
+          data->state = PARSE_HEADER;
+          if ((self->error = process_local_buffer(self, data)) != SHOUTERR_SUCCESS)
+            return self->error;
+          break;
+        }
+        i++;
+      }
+      break;
+    default:
+      debug("Copying data to end of existing buffer\n");
+      append_to_local_buffer(data, buf, len);
+      return self->error = process_local_buffer(self, data);
+  }
+  return self->error = SHOUTERR_SUCCESS;
+}
+
+static void close_aac(shout_t *self) {
+  aac_data_t *aac_data = (aac_data_t *)self->format_data;
+  free(aac_data->buffer);
+  free(aac_data->info);
+  free(aac_data);
+}
+
+
diff -Naur libshout-2.3.1/src/Makefile.am libshout-2.3.1-modified/src/Makefile.am
--- libshout-2.3.1/src/Makefile.am	2012-05-24 20:19:57.000000000 +0200
+++ libshout-2.3.1-modified/src/Makefile.am	2017-08-22 21:41:55.874234999 +0200
@@ -22,7 +22,7 @@
 
 EXTRA_DIST = theora.c speex.c
 noinst_HEADERS = shout_ogg.h shout_private.h util.h
-libshout_la_SOURCES = shout.c util.c ogg.c vorbis.c mp3.c webm.c opus.c $(MAYBE_THEORA) $(MAYBE_SPEEX)
+libshout_la_SOURCES = shout.c util.c ogg.c vorbis.c mp3.c webm.c opus.c aac.c $(MAYBE_THEORA) $(MAYBE_SPEEX)
 AM_CFLAGS = @XIPH_CFLAGS@
 
 libshout_la_LIBADD = net/libicenet.la timing/libicetiming.la avl/libiceavl.la\
diff -Naur libshout-2.3.1/src/shout.c libshout-2.3.1-modified/src/shout.c
--- libshout-2.3.1/src/shout.c	2012-05-24 22:25:35.000000000 +0200
+++ libshout-2.3.1-modified/src/shout.c	2017-08-22 21:46:36.050076999 +0200
@@ -728,7 +728,8 @@
 
 	if (format != SHOUT_FORMAT_OGG
          && format != SHOUT_FORMAT_MP3
-	 && format != SHOUT_FORMAT_WEBM)
+		 && format != SHOUT_FORMAT_WEBM)
+		 && format != SHOUT_FORMAT_AAC)
 		return self->error = SHOUTERR_UNSUPPORTED;
 
 	self->format = format;
@@ -1003,6 +1004,9 @@
 		} else if (self->format == SHOUT_FORMAT_WEBM) {
 			if ((rc = self->error = shout_open_webm(self)) != SHOUTERR_SUCCESS)
 				goto failure;
+		} else if (self->format == SHOUT_FORMAT_AAC) {
+			if ((rc = self->error = shout_open_aac(self)) != SHOUTERR_SUCCESS)
+				goto failure;
 		} else {
                         rc = SHOUTERR_INSANE;
                         goto failure;
@@ -1136,6 +1140,8 @@
 			break;
 		if (self->format == SHOUT_FORMAT_WEBM && queue_printf(self, "Content-Type: video/webm\r\n"))
 			break;
+		if (self->format == SHOUT_FORMAT_AAC && queue_printf(self, "Content-Type: audio/aac\r\n"))
+			break;
 		if (queue_printf(self, "ice-name: %s\r\n", self->name ? self->name : "no name"))
 			break;
 		if (queue_printf(self, "ice-public: %d\r\n", self->public))
diff -Naur libshout-2.3.1/src/shout_private.h libshout-2.3.1-modified/src/shout_private.h
--- libshout-2.3.1/src/shout_private.h	2012-02-02 01:16:37.000000000 +0100
+++ libshout-2.3.1-modified/src/shout_private.h	2017-08-22 21:41:17.165598999 +0200
@@ -109,5 +109,6 @@
 
 int shout_open_ogg(shout_t *self);
 int shout_open_mp3(shout_t *self);
+int shout_open_aac(shout_t *self);
 
 #endif /* __LIBSHOUT_SHOUT_PRIVATE_H__ */
